#! /bin/bash

# enable color support of ls and also add handy aliases
eval "$(dircolors -b)"
alias ls='ls --color=auto'
alias ll='/bin/ls --color=auto -lh'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'

alias copy='head -c -1 | xclip -selection clipboard'
alias ports='sudo netstat -tunpl'
alias rc="code $HOME/.bashrc"

function ps1() {
    # ps + grep
    if [[ $# -eq 0 ]]; then
        echo "Missing search regex"
        return 1
    fi
    
    ps -eo pid,user,cmd | grep -v grep | grep $@
}

function path() {
    if [[ $# -eq 0 ]]; then
        p=$(pwd)
    else
        p=$(realpath $1)
    fi

    echo Copied: $p
    echo $p | copy
}

function where() {
    # show the real file path of a command
    if [[ $# -eq 0 ]]; then
        echo "Missing argument: command"
    else
        echo $(realpath `which $1`)
    fi
}


ENV='ENV_FILE=$BASH_SOURCE && ENV_DIR=$(dirname $BASH_SOURCE) && cd $ENV_DIR'

function home() {
    # cd to the directory containing env.sh
    if [ -z ${ENV_FILE+x} ]; then
        echo "No configed env.sh"
        return 1
    fi
    cd "$ENV_DIR"
}

function e() {
    # edit the current env.sh
    if [ -z ${ENV_FILE+x} ]; then
        echo "No configed env.sh"
        return 1
    fi
    code $ENV_FILE
}

function pskill() {
    if [[ $# -eq 0 ]]; then
        echo "Missing argument: command"
        return 1
    fi

    filter=$1

    pids=$(ps -ef | grep -v grep | grep "$filter" | awk '{print $2}')
    if [ ! -z "$pids" ]; then
        kill $pids
    fi
}

function ccd() {
	cd $(dirname $1)
}

function nbcd() {
    file_path=$1
    cd `dirname $file_path`
    while [ ! -f build.xml ]; do
        cd ..
    done
}


export PATH=$(tr -d $'\n ' <<< "
    $HOME/scripts:
    $PATH
")


alias killnetbeans='ps1 netbeans | f 1 | x kill'

[ -f /home/cuongvt4/zalo/research/elasticsearch/env.sh ] && . /home/cuongvt4/zalo/research/elasticsearch/env.sh
# ===============================================================================================
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize


# lesspipe
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"



# enable bash completion in interactive shells
if ! shopt -oq posix; then
 if [ -f /usr/share/bash-completion/bash_completion ]; then
   . /usr/share/bash-completion/bash_completion
 elif [ -f /etc/bash_completion ]; then
   . /etc/bash_completion
 fi
fi


#save history after every command
#use 'history -r' to reload history
PROMPT_COMMAND="history -a ; $PROMPT_COMMAND"

# reload history
alias r='history -r'



_git_ps1 ()
{
    local g="$(git rev-parse --git-dir 2>/dev/null)"
    if [ -n "$g" ]; then
        local r
        local b
        if [ -d "$g/rebase-apply" ]
        then
            if test -f "$g/rebase-apply/rebasing"
            then
                r="|REBASE"
            elif test -f "$g/rebase-apply/applying"
            then
                r="|AM"
            else
                r="|AM/REBASE"
            fi
            b="$(git symbolic-ref HEAD 2>/dev/null)"
        elif [ -f "$g/rebase-merge/interactive" ]
        then
            r="|REBASE-i"
            b="$(cat "$g/rebase-merge/head-name")"
        elif [ -d "$g/rebase-merge" ]
        then
            r="|REBASE-m"
            b="$(cat "$g/rebase-merge/head-name")"
        elif [ -f "$g/MERGE_HEAD" ]
        then
            r="|MERGING"
            b="$(git symbolic-ref HEAD 2>/dev/null)"
        else
            if [ -f "$g/BISECT_LOG" ]
            then
                r="|BISECTING"
            fi
            if ! b="$(git symbolic-ref HEAD 2>/dev/null)"
            then
                if ! b="$(git describe --exact-match HEAD 2>/dev/null)"
                then
                    b="$(cut -c1-7 "$g/HEAD")..."
                fi
            fi
        fi

        if [ -n "${1-}" ]; then
            printf "$1" "${b##refs/heads/}$r"
        else
            printf " (%s)" "${b##refs/heads/}$r"
        fi
    fi
}

PS1='\n\e[;1;33m\u\e[;1;35m@\e[;1;32m\h \e[;1;36m\w\e[;1;33m$(_git_ps1)\n\[\033[00m\]\$ '

[[ -f ~/.bashrc.local ]] && . ~/.bashrc.local

# ===============================================================================================


#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="/home/cuongvt4/.sdkman"
[[ -s "/home/cuongvt4/.sdkman/bin/sdkman-init.sh" ]] && source "/home/cuongvt4/.sdkman/bin/sdkman-init.sh"
