#! /bin/bash

## for any machine
alias reload='. ~/.bashrc'
alias ls='ls --color=auto'
alias ll='ls --color=auto -lh'
alias lh='ls -d .!(|.)'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias ..='cd ..'
alias -- -='cd -'
alias ports='sudo netstat -tunpl'   # show listening ports
alias fn='find -name'               # find by name
function ftn {                      # find by type and name
    find -type $1 -name "$2"
}
alias du='du -h'
# alias tail='tail -f'


### for personal machines
alias copy='head -c -1 | xclip -selection clipboard' # copy to clipboard
alias r='history -r'                # reload history
alias erc='code ~/.bashrc'          # edit .bashrc
alias ea='code ~/bash/aliases'      # edit aliases


### git
alias g=git
alias gs='git status'
alias gls='git ls-files'
alias ga='git add -A'
alias gc='git commit -m'
alias gac='git commit -am'
alias grs='git reset'
alias gac='git add -A && git commit -m'
alias gp='git push'
alias 'gc!'='git commit -v --amend'
alias gl='git log --pretty='\''format:%Cgreen%h%Creset %an - %s'\'' --graph'
alias gl1='git log --graph --pretty=format:"%Cred%h%Creset %C(yellow)%an%d%Creset %s %Cgreen(%cr)%Creset" --date=relative'


### Docker
alias run='docker run -it --rm'

#################### FUNCTIONS ##############################
function path {
    # tee /dev/tty: only works from a terminal
    if [[ $# == 0 ]]
    then
        # current directory
        pwd | tee /dev/tty | head -c -1 | xclip -selection clipboard
    else
        # a sub path
        realpath $1 | tee /dev/tty | head -c -1 | xclip -selection clipboard
    fi
}


# make ps more useful
# ps1: print all processed
# ps1 <filter>: filtered processed
# ps1 <filter> 1: show pids
# ps1 <filter> 2: kill filtered processs
function ps1 {
    if [[ $# == 0 ]]; then
        ps -ef
    elif [[ $# == 1 ]]; then
        filter=$1
        ps -ef | grep -v grep | grep "$filter"
    else
        if [[ $2 == "pid" || $2 == "p" ]]; then
            ps -ef | grep -v grep | grep "$filter" | awk '{print $2}'
        elif [[ $2 == "kill" || $2 == "k" ]]; then
            ps -ef | grep -v grep | grep "$filter" | awk '{print $2}' | xargs kill
        else
            echo "Unrecognized subcmd: $2"
        fi
    fi
}

function ccd {
	cd $(dirname $1)
}


#### not frequent
function where {
    # show the real file path of a command
    if [[ $# -eq 0 ]]; then
        echo "Missing argument: command"
    else
        echo $(realpath `which $1`)
    fi
}

# ===== for personal computers only
# ENV='ENV_FILE=$BASH_SOURCE && ENV_DIR=$(dirname $BASH_SOURCE) && cd $ENV_DIR'

function home {
    # cd to the directory containing env.sh
    if [[ -v ENV_FILE ]]
    then
        cd "$ENV_DIR"
    else
        echo "No configed env.sh"
        return 1
    fi

}

function e {
    # edit the current env.sh
    if [[ -v ENV_FILE ]] # works for bash >= 4.2 (https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html)
    then
        code $ENV_FILE
    else
        echo "No configed env.sh"
    fi
}

function nbcd {
    file_path=$1
    cd `dirname $file_path`
    while [ ! -f build.xml ]
    do
        cd ..
    done
}